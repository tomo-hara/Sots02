## 전체 동작 흐름 (MFC 이벤트 중심)
### 1) 마우스 클릭 입력 처리
- 핸들러: `ON_WM_LBUTTONDOWN()`
- `OnLButtonDown(UINT nFlags, CPoint point)`에서
  - 클릭 좌표를 컨테이너(예: `std::vector<CPoint>` 또는 `CPoint pts[3]`)에 저장
  - 최대 3개까지만 허용
  - 점 개수에 따라 계산 모델 갱신:
    - 1개: 점만 유지
    - 2개: 기준 직선(Line1) 방정식 도출
    - 3개: 수선(Line2) 방정식 도출 + 교점 계산
- 모델 갱신 후 `Invalidate(FALSE)` 호출로 **Paint 사이클 트리거**
  - 즉시 그리기는 피하고, **항상 OnPaint에서 모델 기반 재렌더링**하도록 설계

---

## 렌더링 설계 (WinAPI Native 중심 + 더블 버퍼링 권장)
### 2) Paint 루틴
- 핸들러: `OnPaint()`
- MFC의 `CPaintDC dc(this)`로 HDC 확보 후,
- 그리기 작업은 `dc`의 래퍼를 최소화하고 **Native GDI API**로 수행:
  - `Ellipse` (점)
  - `MoveToEx / LineTo` (직선/수선)
  - `TextOut / DrawText` (교점 좌표 출력)

### 3) 깜빡임 방지 및 고성능: 더블 버퍼링 (Memory DC)
- `CreateCompatibleDC`, `CreateCompatibleBitmap`으로 메모리 DC 구성
- 전체 장면을 메모리 DC에 그린 뒤 `BitBlt`로 화면에 한 번에 출력
- `OnEraseBkgnd`에서 배경 지우기 최소화(필요 시 `return TRUE`)로 플리커 감소

---

## GDI 리소스 관리 (A)
### 4) Pen/Brush 생성·해제 및 SelectObject 관리
렌더링 시마다 필요한 스타일(점/직선/수선/교점)에 맞춰 펜/브러시를 생성하고,  
`SelectObject`로 적용한 뒤 **원래 오브젝트로 복구**하고 **DeleteObject로 해제**하여 리소스 누수를 방지합니다.

- 예시 정책
  - 점: `HPEN` + `HBRUSH` (채움 원)
  - 기준 직선: 굵기/스타일 다른 `HPEN`
  - 수선: 구분되는 `HPEN` (점선 등)
  - 교점: 점 표시용 펜/브러시 + 텍스트 출력용 폰트(선택)

> 핵심: `SelectObject(hdc, pen)` 후 반환된 oldPen을 반드시 다시 선택해 복구한 뒤 `DeleteObject(pen)` 호출

---

## 직선 표현 방식: “선분”이 아닌 “클라이언트 끝까지” (B)
### 5) 직선 렌더링 전략
두 점으로 정의되는 직선은 단순히 두 점 사이를 잇는 선분이 아니라,  
**클라이언트 영역 경계까지 연장되는 “무한 직선” 형태**로 그립니다.

- 절차
  1. 직선을 일반형으로 저장: `ax + by + c = 0`
  2. 클라이언트 폭/높이(`GetClientRect`)를 구함
  3. 경계선과의 교점 후보를 계산해 화면 안에 들어오는 두 점을 선택
     - 예: `x=0`, `x=width`에서의 y 계산 또는 `y=0`, `y=height`에서의 x 계산
  4. 선택된 두 점으로 `MoveToEx/LineTo`로 직선을 그림

- 장점
  - 직선의 개념이 시각적으로 명확
  - 확대/리사이즈에도 동일한 수학적 대상이 일관되게 표현됨

---

## 기하 계산 (방정식/교점)
### 6) 직선 방정식: 일반형(ax+by+c=0) 채택
- 수직선에서 `y=mx+b`가 불안정해지는 문제를 피하기 위해,
- 모든 직선을 **일반형**으로 저장하여 안정성을 확보합니다.

- 두 점 `(x1,y1)`, `(x2,y2)`로부터 예시
  - `a = y1 - y2`
  - `b = x2 - x1`
  - `c = x1*y2 - x2*y1`

> 추가로, 두 점이 동일한 경우(퇴화 케이스)는 직선이 정의되지 않으므로 입력 무시/경고 처리

### 7) 수선(직교선) 방정식 도출
- 기준 직선 `a1x + b1y + c1 = 0`에 대해,
- 3번째 점 `P(x0,y0)`를 지나는 수선을 `a2x + b2y + c2 = 0` 형태로 도출합니다.
- 직교 조건을 이용해 수선 계수를 구성하고, 점 P를 대입해 `c2`를 결정합니다.
- 수선도 동일 방식으로 **클라이언트 끝까지** 연장 렌더링합니다.

### 8) 교점 계산
- 기준 직선(Line1)과 수선(Line2)을 연립하여 교점 `(x*, y*)`를 구합니다.
- `det = a1*b2 - a2*b1`
  - `det == 0`이면 평행/일치 → 교점 없음/무한 → 예외 처리
- 교점은 실수 좌표로 저장(예: `double`)하고, 그리기 시 반올림하여 픽셀 좌표로 변환

---

## 교점 표시: 텍스트 출력 (C)
### 9) 교점 시각화
- 교점 좌표를 텍스트로 출력합니다.
  - 예: `"Intersection: (123.45, 67.89)"`

---

## 예외/경계 케이스 처리
- 두 점이 같은 위치: 직선 정의 불가 → 입력 무시 또는 안내 메시지
- 수직/수평선: 일반형 표현으로 안전하게 처리
- det==0(평행/일치): 교점 계산 불가 → 교점 표시 생략
- 점 3개 이후 입력: 자동 리셋 또는 별도 “Reset” 버튼/단축키로 초기화

---

## 설계 포인트 한 줄
**MFC로 입력/상태 전이를 명확히 관리하고, 고빈도 렌더링은 WinAPI Native GDI + 더블 버퍼링으로 처리하여 성능과 안정성을 동시에 확보했습니다.**
